"""
    initialize_tableau(n)

Construct a tableau for the stabilizer representation of a state on n qubits.
The tableau is initialized with stabilizer generator generated by all ``Z_i``
"""
function initialize_tableau(n::Int)
    tableau = falses(2n+1, 2n+2)
    for i=1:(2n)
        tableau[i,i] = 1
    end
    return tableau
end

"""
    g(x1, z1, x2, z2)

Compute the sign arising from the product of two elements of the tableau with
X and Z components given by x1, x2, z1, and z2. Called in rowsum.
"""
function g(x1,z1,x2,z2)
    if x1 == z1 == 0
        return 0
    elseif x1 == z1 == 1
        return z2 - x2
    elseif x1 == 1 && z1 == 0
        return z2 * (2 * x2 - 1)
    else
        return x2 * (1 - 2 * z2)
    end
end

"""
    rowsum(t, h, i, n)

Compute the function rowsum (see Aaronson ...) for rows h and i of the tableau
for a system of n qubits. Rowsum computes the product of the two rows.
"""
@inline function rowsum(tableau::BitArray, h::Int, i::Int, n::Int)
    tableau[h,1:(2n)] .= (tableau[i,1:(2n)] .⊻ tableau[h,1:(2n)])
    tableau[h, 2n+1] ⊻= mod(tableau[i, 2n+1] + dot(tableau[i,1:n], tableau[h,(n+1):2n]), 2)
    return tableau
end

"""
    rowsum_op(op1, op2, n)

Compute the rowsum of two operators over n qubits.
"""
function rowsum_op(op1::BitArray, op2::BitArray, n::Int)
    gSum = mod(sum(g.(op1[1:n],op1[(n+1):2n],op2[1:n],op2[(n+1):2n])), 4)
    op2[2n+1] = (mod(gSum + 2*(op2[2n+1] + op1[2n+1]), 4) != 0)
    op2[1:(2n)] .= (op1[1:(2n)] .⊻ op2[1:(2n)])
    return op2
end

"""
    rowswap!(t, ind1, ind2)

Swap rows ind1 and ind2 in the tableau. This function operates inplace.
"""
function rowswap!(tableau::BitArray, ind1::Int, ind2::Int)
    tableau[ind1, :] .⊻= tableau[ind2, :]
    tableau[ind2, :] .⊻= tableau[ind1, :]
    tableau[ind1, :] .⊻= tableau[ind2, :]
end

"""
    check_commute(op1, op2, n)

Return whether two n-qubit operators op1 and op2 commute.
"""
function check_commute(op1::BitArray, op2::BitArray, n::Int)
    return (dot(op1[1:n], op2[(n+1):2n]) + dot(op1[(n+1):2n], op2[1:n])) % 2 == 0
end

"""
    print_operator(op, n)

Print the n-qubit Pauli string op.
"""
function print_operator(op, n)
    str = ""
    for j = 1:n
        if op[j] == 1 && op[j+n] == 1
            str = string(str, "Y")
        elseif op[j] == 1 && op[j+n] == 0
            str = string(str, "X")
        elseif op[j+n] == 1
            str = string(str,"Z")
        else
            str = string(str,"I")
        end
    end
    println(str)
end
